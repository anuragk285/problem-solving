# Last Day where you can still cross

```java
class Solution {
    int[][] cells;
    int row, col;
    public int latestDayToCross(int row, int col, int[][] cells) {
        this.cells = cells;
        this.row = row;
        this.col= col;
        int low = 0, high = cells.length-1, ans = -1;
        while(low <= high){
            int mid = (low + high)/2;
            if(pathExists(mid)){
                ans = mid;
                //System.out.println("Path exists upto day: "+(mid+1));
                low = mid+1;
            }else{
                //System.out.println("Path Does not exists at day: "+(mid+1));
                high = mid-1;
            }
        }
        return ans+1;
    }
    private boolean pathExists(int day){
        int[][] grid = new int[row][col];
        for(int i=0; i<=day; i++){
            int r = cells[i][0]-1, c = cells[i][1]-1;
            grid[r][c] = 1;
        }
        boolean[][] visited = new boolean[row][col];
        Queue<int[]> queue = new LinkedList<>();
        for(int j=0; j<col; j++){
            if(grid[0][j] == 0){
                visited[0][j] = true;
                queue.add(new int[]{0, j});
            }
        }
        while(!queue.isEmpty()){
            int[] cor = queue.poll();
            int r = cor[0], c = cor[1];
            if(r == row-1) return true;
            int[] nx = {r, r+1, r, r-1};
            int[] ny = {c+1, c, c-1, c};
            for(int idx=0; idx<4; idx++){
                int nr = nx[idx], nc = ny[idx];
                if(isValid(nr, nc) && !visited[nr][nc] && grid[nr][nc] == 0){
                    visited[nr][nc] = true;
                    queue.add(new int[]{nr, nc});
                }
            }
        }
        return false;
    }
    private boolean isValid(int i, int j){
        if(i<0 || i>=row || j<0 || j>=col) return false;
        return true;
    }
}
```
