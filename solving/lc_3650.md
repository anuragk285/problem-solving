# Minimum Cost Path with Edge Reversal

```java
class Solution {
    class Pair{
        int node, cost;
        Pair(int node, int cost){
            this.node = node;
            this.cost = cost;
        }
    }
    public int minCost(int n, int[][] edges) {
        int[] minCost = new int[n];
        Arrays.fill(minCost, Integer.MAX_VALUE);
        minCost[0] = 0;
        List<List<int[]>> graph = new ArrayList<>();
        List<List<int[]>> rev = new ArrayList<>();
        for(int i=0; i<n; i++){
            graph.add(new ArrayList<>());
            rev.add(new ArrayList<>());
        }
        for(int[] e : edges){
            int u = e[0], v = e[1], c = e[2];
            graph.get(u).add(new int[]{v, c});
            rev.get(v).add(new int[]{u, 2*c});
        }
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> Integer.compare(a.cost, b.cost));
        pq.add(new Pair(0, 0));
        while(!pq.isEmpty()){
            Pair p = pq.poll();
            int u = p.node, c = p.cost;
            if(c > minCost[u]) continue;
            for(int[] nextNode : graph.get(u)){
                if(minCost[u] + nextNode[1] < minCost[nextNode[0]]){
                    minCost[nextNode[0]] = minCost[u] + nextNode[1];
                    pq.add(new Pair(nextNode[0], minCost[nextNode[0]]));
                }
            }
            for(int[] nextRevNode : rev.get(u)){
                if(minCost[u] + nextRevNode[1] < minCost[nextRevNode[0]]){
                    minCost[nextRevNode[0]] = minCost[u] + nextRevNode[1];
                    pq.add(new Pair(nextRevNode[0], minCost[nextRevNode[0]]));
                }
            }
        }
        int ans = minCost[minCost.length-1];
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }
}
```
